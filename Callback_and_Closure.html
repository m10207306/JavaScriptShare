<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Callback & Closure</title>
  </head>

  <body>
    
    <script>
      // Callback Function 基本範例
      // Callback => Call me back
      // 會有兩個重點：將func1做為參數傳入func2, 並由func2控制呼叫func1時機
      function func2() {
        console.log("func2");
      }

      function func1(callback_func) {
        // do something
        callback_func();
      }

      func1(func2);

      // Callback function 是CPS(Continuation-passing Style)延續傳遞風格的實作 (與它相對的是Direct Style直接風格)
      // DS
      function direct_style(x) {
        return x;
      }
      // CPS
      function CPS_style(x, callback_func) {
        callback_func(x);
      }

      // 另一個例子
      // DS
      function getuser(user) {
        // do something
        return user;
      }

      function display(content) {
        console.log(content);
      }

      const user = getuser("Derick");
      display(user);
      
      // CPS
      function getuser2(user, callback_func) {
        callback_func(user);
      }

      getuser2("Derick", display);  // 這邊Display沒改
      
      ///////////////////////////////////////////////////////////////////

      // Callback Function 主要用途
      // 1. 在同步與非同步的狀況下保證函式的執行順序
      function func3(funcA, funcB) {
        funcA(funcB);
      }

      function func4(fn) {
        fn();
      }

      function func5() {
        console.log("Finish");
      }

      func3(func4, func5);

      // 2. 便於維護
      // 以上面的例子去延續, 如果希望加入一個Start的console.log只需要修改:
      function func6(fn) {
        console.log("Start!");
        fn;                         // 特別, 不用加小括號
      }

      func6(func3(func4, func5));

      ///////////////////////////////////////////////////////////////////

      // Callback Function 目前已經應用的案例
      
      // array.filter(callback)
      //              => callback(element) { ... return True/False; }
      // 實際實作:
      // let newArr = [];
      //
      // for (let i = 0; i < this.length; ++i) {
      //   if (callback[this[i]]) {
      //     newArr.push(this[i]);
      //   }
      // }
      // return newArr;

      ///////////////////////////////////////////////////////////////////

      // Callback Function 的缺點 - Callback Hell
        // 巢狀callback造成難以一眼看出執行順序, 假設這些function都是類似addEventListener或是setTimeout一樣會異步執行
        // doA(function() {
        //   doB();

        //   doC(function() {
        //     doD();
        //   });

        //   doE();
        // });

        // doF();

        // 執行順序為: doA, doF (因為異步, doA的callback還沒執行), doB, doC, doE, doD

      // Callback Function 的缺點 - 控制權轉移（信任問題）
        // 第三方提供的程式
        // function trackPurchase(purchaseData, callback) {
        //   // Do something
        //   callback();
        // }

        // trackPurchase(price, function() { // 控制權轉至 trackPurchase
        //   // 完成追蹤後，執行刷卡動作，完成結帳
        //   chargeCreditCard();
        // });

        // 要把trackPurchase當成一個異步的Function
        // 這時突然因為某些原因trackPurchase被連續呼叫多次, 就會造成信用卡被多次刷卡
        // 我的理解是當Mission放下去給trackPurchase之後你就無法再去控制或是打斷他去執行callback

      // Callback Function 的缺點 - 無法用Try Catch去處理錯誤
        // 同步情境(才可以用try catch)
        // const fs = require('fs')
        // try {
        //   const file = fs.readFileSync('./README.md') // 讀取檔案
        // }
        // catch(err) {
        //   console.log('讀檔失敗')
        // }

        // 非同步情境
        // try {
        //   fs.readFile('./README.md', (err, data) => {     // 這邊還有一個error first的特性
        //     console.log(data) // 印出內容
        //   })
        // }
        // catch(err) {
        //   console.log('讀檔失敗')
        // }

        // 這樣是無法抓出Error的


      // 解決 Callback Function 缺點的方法: Promise
      
      ///////////////////////////////////////////////////////////////////

      // Closure
      // Function在JS為First-Class Function, 也就是跟其他變數一樣可被當成參數傳遞, typeof會回傳function
      // 所以當函式建立時會存在閉包這個資料結構, 包含函式本身 以及 記憶函示被創立時的環境
      function aFunc(x) {
        function bFunc() {    // 也可以是匿名函式
          console.log(x++);
        }

        return bFunc;
      }

      const newFunc = aFunc(1); // aFunc(1)是「函式呼叫」, newFunc這邊是「函式建立」
      newFunc();
      newFunc();

      // 甚至可以一路往外抓, 抓到全域變數
      const varGlobal = 'x'
      function outer(paramOuter){
        const varOuter ='y'
        function inner(paramInner){
          const varInner ='z'
          //print
          console.log(varGlobal)
          console.log(varOuter)
          console.log(varInner)
          console.log(paramOuter)
          console.log(paramInner)
        }
        return inner
      }

      const func = outer('a')
      func('b')

      ///////////////////////////////////////////////////////////////////

      // 但是需要注意的是, 對於「外部的變數」他並非「複製這些變數」, 而是留下Reference
      function counter() {
          let i = 0
          for (i = 0; i< 5; i++) {
              setTimeout(function() {
                  console.log('counter is ' + i)
              }, 1000)
          }
      }

      counter()   // 這邊會連續print出5個5, 而不是0, 1, 2, 3, 4

      // 如果不希望這樣子要改寫成: 
      function counter2(x) {
        setTimeout(function() {
            console.log('counter is ' + x)
        }, 1000)
      }

      for (i = 0; i < 5; i++) {
          counter2(i);
      }

      // 或是用閉包解決閉包
      function print(i){
        return function(){
        console.log('counter is ' + i)
        }
      }

      function counter3() {
        let i = 0
        for (i = 0; i< 5; i++) {
            setTimeout(print(i), 1000)
        }
      }
      
      counter3();

      // 不然就要用IIFE(Immediately-Invoked Function Expression)立即呼叫函式表達式
      for (let i = 0; i < 5; i++) {
        (function(value) {
          setTimeout(function(){
            console.log('counter is ' + value);
          }, 1000)
        })(i)
      }

      // 有兩個環境變數不會被閉包紀錄：this, arguments

      ///////////////////////////////////////////////////////////////////

      // Closure 應用: 科里化 Curry
      // 將原先傳入多個參數的Function可以拆解成每次呼叫傳入一個參數

      // 原先:
      function multiply(x, y){
        return x * y;
      }

      multiply(3, 5); // 15 

      // Curry
      function curriedMultiply(x) {
        return function(y) {
          return x * y;
        }
      }

      var curriedObj = curriedMultiply(5);
      curriedObj(3); // 15
      // or 
      curriedMultiply(3)(5);  // 15

    </script>

  </body>
</html>
